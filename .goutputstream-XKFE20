import ij.*;
import ij.ImagePlus;
import ij.gui.GenericDialog;
import ij.plugin.filter.PlugInFilter;
import ij.process.*;
import ij.util.ArrayUtil;
import java.awt.*;
import java.lang.Math;
import java.util.ArrayList;

public class Harris_Eckendetektor implements PlugInFilter {
	
	public int setup(String arg, ImagePlus imp) {
		return DOES_ALL+SUPPORTS_MASKING;
	}

	public void run(ImageProcessor ip) {
		GenericDialog gd = new GenericDialog("Optionen");
		Dimension screensize = Toolkit.getDefaultToolkit().getScreenSize();
		gd.setSize(200, 100);
		gd.addNumericField("Empfindlichkeit: ", 1.0, 2);
		gd.addNumericField("Schwellwert: ", 4.0, 2);
		gd.addCheckbox("Zeige Gradientenbilder", true);
		gd.setLocation((int)screensize.getWidth()/2, (int)screensize.getHeight()/2);
		gd.showDialog();
		
		if (gd.wasCanceled()) return;
		
		/* Empfindlichkeit der Eckendetektion */
		double i = gd.getNextNumber();
		
		/* Schwellwert */
		double t = gd.getNextNumber();
		
		/* Flag für Gradientenbilder */
		boolean show_grad = gd.getNextBoolean();
		
		/* Schleifenzähler */
		int x, y;

		/* Bilddimensionen */
		int w = ip.getWidth();
		int h = ip.getHeight();
		
		double s_x, s_y;
		
		/* "Strukturmatrix" M
		 *		/ A	C \
		 * 		\ C	B /
		 */
		double A, B, C, c;
		
		/* hier landen dann die Eck-Kandidaten */
		ArrayList<Point> edges = new ArrayList<Point>();

		/* lege Graustufenkopie an */
		ImageProcessor ip_gs = ip.convertToFloat();
		
		ImageProcessor ip_gradx = new FloatProcessor();
		
		/* Algorithmus 16.1 [Nischwitz] */
		for (y = 0; y < h; y++) {
			for (x = 0; x < w; x++) {
				/* bestimme partielle Ableitungen; negative Werte werden im nächsten Schritt positiv */
				s_x = (double)((ip_gs.getPixelValue(x+1, y) - ip_gs.getPixelValue(x, y)) +
							   (ip_gs.getPixelValue(x-1, y) - ip_gs.getPixelValue(x, y))) / 255.0;
				s_y = (double)((ip_gs.getPixelValue(x, y+1) - ip_gs.getPixelValue(x, y)) +
							   (ip_gs.getPixelValue(x, y-1) - ip_gs.getPixelValue(x, y))) / 255.0;
				
				/* bestimme M */
				A = s_x * s_x;
				B = s_y * s_y;
				C = s_x * s_y;
				
				c = Math.abs((A * B) - (C * C) - i * Math.pow(A + B, 2.0));
				
				/* falls mögliche Ecke (C(x, y) >= tau), speichere Koordinaten */
				if (c >= t) {
					edges.add(new Point(x, y));
				}
			}
		}
		
		// TODO eventuell kacheln und lokale Schwellwerte ermitteln
		
		ImageProcessor ip_out = ip.duplicate();
		
		/* Ecken einkreisen */
		ip_out.setColor(0xff00ff);
		ip_out.setLineWidth(1);
		
		for (Point p: edges) {
			ip_out.drawOval((int)p.getX()-3, (int)p.getY()-3, 6, 6);
		}

        IJ.log("Harris Eckendetektor: i="+i+", t="+t+", #edges="+edges.size());
		
		/* Ausgabe anzeigen */
		new ImagePlus("Hier sind die Ecken!", ip_out).show();
	}

}

